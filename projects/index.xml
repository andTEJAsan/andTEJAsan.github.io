<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Projects on Tejas Anand</title>
    <link>https://andTEJAsan.github.io/projects/</link>
    <description>Recent content in Projects on Tejas Anand</description>
    <generator>Hugo -- 0.128.0</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 30 Jul 2024 17:15:58 +0530</lastBuildDate>
    <atom:link href="https://andTEJAsan.github.io/projects/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Market Making Limit OrderBook</title>
      <link>https://andTEJAsan.github.io/projects/lobook/</link>
      <pubDate>Tue, 30 Jul 2024 17:15:58 +0530</pubDate>
      <guid>https://andTEJAsan.github.io/projects/lobook/</guid>
      <description>During the summer in kyoto I got the chance to participate in a simulated trading event called Trade-A-Thon organized by Optiver. It was an exciting event for me, as I learnt about market making and what an order book is. Upon seeing the simple UI of the platform on which the event was conducted I thought to myself that I should try building it, as it would be a good exercise for me to learn about orderbooks as well.</description>
    </item>
    <item>
      <title>ChaTRoom using boost::asio</title>
      <link>https://andTEJAsan.github.io/projects/chatroom/</link>
      <pubDate>Tue, 30 Jul 2024 17:03:39 +0530</pubDate>
      <guid>https://andTEJAsan.github.io/projects/chatroom/</guid>
      <description>This project is a simple chat room application implemented using the boost::asio library in C++. The chat room allows multiple clients to connect to a server and exchange messages in real-time. The server acts as a central hub, relaying messages between clients.
You can also whisper to specific clients by mentioning their username in the message. The server will ensure that the message is delivered only to the intended recipient.</description>
    </item>
    <item>
      <title>Building Reliable Congestion Control Protocol</title>
      <link>https://andTEJAsan.github.io/projects/tcp/</link>
      <pubDate>Tue, 30 Jul 2024 16:53:42 +0530</pubDate>
      <guid>https://andTEJAsan.github.io/projects/tcp/</guid>
      <description>The objective of this assignment was to design a TCP protocol capable of downloading and uploading reliably while dealing with congestion efficiently The server was implemented as a leaky bucket, every time we sent a request our tokens would get consumed, if our bucket became empty we would get squished and get penalised. The server would also randomly drop packets, designed to simulate a real time network. So we had to modify the rate of sending requests adaptively based on various metrics like EWMA RTT, Last squish time to optimise for speed while maintaining reliability.</description>
    </item>
    <item>
      <title>Distributed Maze Generator</title>
      <link>https://andTEJAsan.github.io/projects/distrgraph/</link>
      <pubDate>Tue, 30 Jul 2024 16:46:09 +0530</pubDate>
      <guid>https://andTEJAsan.github.io/projects/distrgraph/</guid>
      <description>In this project, I undertook implemented distributed versions of well-known graph algorithms such as Prim&amp;rsquo;s, Dijkstra&amp;rsquo;s, Kruskal&amp;rsquo;s, DFS, and BFS specifically tailored for maze generation and solving, using the MPI library in C++.
To achieve parallelization, I employed a strategy for BFS and Dijkstra&amp;rsquo;s algorithms. I introduced the concept of node ownership, assigning specific nodes in the graph to different processors. This allowed for a more balanced distribution of work and enabled efficient parallel processing of the graph.</description>
    </item>
    <item>
      <title>Copy on Write with Swapping in xv6</title>
      <link>https://andTEJAsan.github.io/projects/cowxv6/</link>
      <pubDate>Tue, 30 Jul 2024 16:35:57 +0530</pubDate>
      <guid>https://andTEJAsan.github.io/projects/cowxv6/</guid>
      <description>Copy on Write (COW) is a memory management technique that allows multiple processes to share the same memory pages until one of them modifies the content. When a process attempts to modify a shared page, a copy of that page is created, ensuring that the original page remains unchanged. This approach minimizes memory duplication and improves efficiency by reducing the need for unnecessary memory copies.
Swapping, on the other hand, is a process where the operating system moves pages of memory between the physical memory (RAM) and the disk.</description>
    </item>
  </channel>
</rss>
