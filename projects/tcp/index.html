<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building Reliable Congestion Control Protocol | Tejas Anand</title>
<meta name=keywords content><meta name=description content="The objective of this assignment was to design a TCP protocol capable of downloading and uploading reliably while dealing with congestion efficiently The server was implemented as a leaky bucket, every time we sent a request our tokens would get consumed, if our bucket became empty we would get squished and get penalised. The server would also randomly drop packets, designed to simulate a real time network. So we had to modify the rate of sending requests adaptively based on various metrics like EWMA RTT, Last squish time to optimise for speed while maintaining reliability."><meta name=author content="Tejas Anand"><link rel=canonical href=https://andTEJAsan.github.io/projects/tcp/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://andTEJAsan.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andTEJAsan.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andTEJAsan.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://andTEJAsan.github.io/apple-touch-icon.png><link rel=mask-icon href=https://andTEJAsan.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://andTEJAsan.github.io/projects/tcp/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Building Reliable Congestion Control Protocol"><meta property="og:description" content="The objective of this assignment was to design a TCP protocol capable of downloading and uploading reliably while dealing with congestion efficiently The server was implemented as a leaky bucket, every time we sent a request our tokens would get consumed, if our bucket became empty we would get squished and get penalised. The server would also randomly drop packets, designed to simulate a real time network. So we had to modify the rate of sending requests adaptively based on various metrics like EWMA RTT, Last squish time to optimise for speed while maintaining reliability."><meta property="og:type" content="article"><meta property="og:url" content="https://andTEJAsan.github.io/projects/tcp/"><meta property="article:section" content="projects"><meta property="article:published_time" content="2024-07-30T16:53:42+05:30"><meta property="article:modified_time" content="2024-07-30T16:53:42+05:30"><meta property="og:site_name" content="Tejas Anand"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building Reliable Congestion Control Protocol"><meta name=twitter:description content="The objective of this assignment was to design a TCP protocol capable of downloading and uploading reliably while dealing with congestion efficiently The server was implemented as a leaky bucket, every time we sent a request our tokens would get consumed, if our bucket became empty we would get squished and get penalised. The server would also randomly drop packets, designed to simulate a real time network. So we had to modify the rate of sending requests adaptively based on various metrics like EWMA RTT, Last squish time to optimise for speed while maintaining reliability."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"https://andTEJAsan.github.io/projects/"},{"@type":"ListItem","position":2,"name":"Building Reliable Congestion Control Protocol","item":"https://andTEJAsan.github.io/projects/tcp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building Reliable Congestion Control Protocol","name":"Building Reliable Congestion Control Protocol","description":"The objective of this assignment was to design a TCP protocol capable of downloading and uploading reliably while dealing with congestion efficiently The server was implemented as a leaky bucket, every time we sent a request our tokens would get consumed, if our bucket became empty we would get squished and get penalised. The server would also randomly drop packets, designed to simulate a real time network. So we had to modify the rate of sending requests adaptively based on various metrics like EWMA RTT, Last squish time to optimise for speed while maintaining reliability.","keywords":[],"articleBody":" The objective of this assignment was to design a TCP protocol capable of downloading and uploading reliably while dealing with congestion efficiently The server was implemented as a leaky bucket, every time we sent a request our tokens would get consumed, if our bucket became empty we would get squished and get penalised. The server would also randomly drop packets, designed to simulate a real time network. So we had to modify the rate of sending requests adaptively based on various metrics like EWMA RTT, Last squish time to optimise for speed while maintaining reliability. Strategies Implemented Having separate threads for sending and receiving packets Tweaking the sleep time between sending consecutive requests based on the measured response time i.e (Expontentially Weighted Moving Average) which represents the current state of server responses. Sending requests in bursts and adaptively changing burst size Since the server was dropping packets randomly even when squishing wasn’t present, so only going into cautious mode if the measured rate of dropping became higher than a threshold. View the project on GitHub\n","wordCount":"175","inLanguage":"en","datePublished":"2024-07-30T16:53:42+05:30","dateModified":"2024-07-30T16:53:42+05:30","author":{"@type":"Person","name":"Tejas Anand"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://andTEJAsan.github.io/projects/tcp/"},"publisher":{"@type":"Organization","name":"Tejas Anand","logo":{"@type":"ImageObject","url":"https://andTEJAsan.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andTEJAsan.github.io/ accesskey=h title="Tejas Anand (Alt + H)"><img src=https://andTEJAsan.github.io/img/coding.png alt aria-label=logo height=35>Tejas Anand</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://andTEJAsan.github.io/blogs/ title=Blogs><span>Blogs</span></a></li><li><a href=https://andTEJAsan.github.io/about/ title=About><span>About</span></a></li><li><a href=https://andTEJAsan.github.io/projects/ title=Projects><span>Projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://andTEJAsan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://andTEJAsan.github.io/projects/>Projects</a></div><h1 class="post-title entry-hint-parent">Building Reliable Congestion Control Protocol</h1><div class=post-meta><span title='2024-07-30 16:53:42 +0530 IST'>July 30, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Tejas Anand</div></header><div class=post-content><p><img loading=lazy src=/img/tcp.png alt=Image></p><ol><li>The objective of this assignment was to design a TCP protocol capable of downloading and uploading reliably while dealing with congestion efficiently</li><li>The server was implemented as a leaky bucket, every time we sent a request our tokens would get consumed, if our bucket became empty we would get squished and get penalised.</li><li>The server would also randomly drop packets, designed to simulate a real time network.</li><li>So we had to modify the rate of sending requests adaptively based on various metrics like EWMA RTT, Last squish time to optimise for speed while maintaining reliability.</li></ol><h2 id=strategies-implemented>Strategies Implemented<a hidden class=anchor aria-hidden=true href=#strategies-implemented>#</a></h2><ul><li>Having separate threads for sending and receiving packets</li><li>Tweaking the sleep time between sending consecutive requests based on the measured response time i.e (Expontentially Weighted Moving Average) which represents the current state of server responses.</li><li>Sending requests in bursts and adaptively changing burst size</li><li>Since the server was dropping packets randomly even when squishing wasn&rsquo;t present, so only going into cautious mode if the measured rate of dropping became higher than a threshold.</li></ul><p><a href=https://github.com/andTEJAsan/TCP_reliable_congestion_control>View the project on GitHub</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://andTEJAsan.github.io/projects/chatroom/><span class=title>« Prev</span><br><span>ChaTRoom using boost::asio</span>
</a><a class=next href=https://andTEJAsan.github.io/projects/distrgraph/><span class=title>Next »</span><br><span>Distributed Maze Generator</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://andTEJAsan.github.io/>Tejas Anand</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>